\documentclass{article}

\usepackage[brazilian]{babel}
\usepackage{indentfirst}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{csquotes}
\usepackage{caption}
\usepackage{fontawesome5}
\usepackage{textcomp}
\usepackage[usenames,dvipsnames]{color}


\MakeOuterQuote{"}

\hypersetup{
	colorlinks=true,
	filecolor=black,
	linkcolor=black,
	urlcolor=cyan
}

\pagestyle{empty}

\begin{document}

	\title {Computação básica \\[1ex] \large Uma simples introdução ao Linux, Python e Git}
	\date{}
	\author{Omar Mesquita}
	\maketitle
	
	\newpage
	\tableofcontents


	\newpage
	\section{Linux}
	\subsection{Por que?}
	
	Em muitos projetos de desenvolvimento de software, os grupos de pesquisa e as empresas envolvidas optam por  
	usar o Linux. Caso não tenha ouvido falar, o \href{https://pt.wikipedia.org/wiki/Linux}{Linux}, também chamado de GNU/Linux, é um sistema operacional como o 
	Windows da Microsoft ou o MacOS da Apple. 


	O que torna ele especial é seu alto grau de \textit{liberdade} , o qual facilita muito a vida de quem trabalha com 
	desenvolvimento, operações e/ou administração de sistemas. Esse aspecto do Linux se expressa em várias características 
	como o fato de ser \href{https://pt.wikipedia.org/wiki/C%C3%B3digo_aberto}{código aberto}. No entanto, para fins desse livreto, ele se resume à agilidade
	e à eficiência de sua \textbf{linha de comando}.

	\subsection{Linha de comando? Aquele négocio de 1990?} 

	Resumidamente, sim. Agora, antes que isso pareça uma má ideia, posso garantir a você que uma vez entendida a essência da
	linha de comando e seus principais comandos, sua produtividade como pessoa desenvolvedora vai aumentar muito! 

	Conheço pessoas que já desenvolveram muito código (principalmente no Windows), 
	mas ficaram hesitantes quanto ao uso da CLI (sigla para interface de linha de comando, em inglês) 
	pela sua natureza um tanto "retrô" e por receio de não aprender todos os comandos, e,
	consequentemente, perder sua preciosa produtividade. 

	O lado bom é que ninguém sabe todos os comandos e realmente não é necessário. A \textbf{curva de aprendizado} pode, 
	inicialmente, parecer muito difícil de superar, mas não se iluda, você irá entender rapidinho. 

	Se familiarizar com a CLI, como qualquer processo de aprendizado, está sujeito ao \href{https://jornal.usp.br/radio-usp/o-que-e-o-efeito-dunning-kruger/}{efeito Dunning Kruger}. 
	Inicialmente, você pode se desesperar achando que será algo difícil, tedioso ou demorado para dominar, mas assim que
	começar a praticar, as coisas vão ficando mais claras. 

	\begin{figure}[ht!]
  		\centering
		\includegraphics[scale=0.3]{figs/dk.jpeg} 
  		\caption*{O efeito Dunning Kruger. Não deixe que o primeiro pico te desmotive!}
	\end{figure}

	\newpage
	Falando de comandos agora - vamos começar com os básicos, isto é, aqueles que você usa todo dia só que de forma gráfica
	em programas como o Explorador do Windows. Tomando o Ubuntu Linux como referência, começamos nossa jornada no mundo CLI
	procurando um aplicativo chamado \textbf{Terminal}. Ao clicar nele, você irá se deparar com algo assim: 
	
	\vspace{1ex}
	\texttt{user@linux: ~}
	\vspace{1ex}

	O que significa que a pessoa usuária de nome \texttt{user} está, ou "at" em inglês, (\texttt{@}) no computador de nome
	\texttt{linux}. Depois dos dois pontos, irão aparecer os comandos que você digitar. Tais comandos serão interpretados pela
	\textit{shell} - um programa que roda "por trás das cortinas" e analisa os comandos para saber se são válidos ou não.

	Dado esse contexto, podemos começar a usar o computador com o poder da CLI. Geralmente, a primeira coisa que se faz ao 
	entrar no computador é saber onde você está. 
	
	\subsubsection{Onde estou? O pwd}
	Para descobrir sua localização no sistema de arquivos, digite \texttt{pwd} e pressione Enter. Esse comando vêm de 
	\textit{print working directory}, o que traduz, a grosso modo, para "mostre o diretório no qual se está trabalhando". O
	resultado esperado é um caminho ou \textit{path} como \texttt{/home/user}. 

	Isso indica que você está na pasta pessoal, ou "lar", de \texttt{user}. Essa pasta, por sua vez, está 
	na coleção de "lares" das pessoas que usam o sistema (\texttt{/home}). Por fim, essa coleção é só mais uma pasta no que 
	se chama de \textbf{raiz} do sistema de arquivos, representada por um \texttt{/}. 

	\subsubsection{O que eu tenho? O ls} 

	Agora que você sabe onde está, como descobrir o que tem em cada pasta? Para isso, use o comando \texttt{ls}. Isso deve
	retornar a \textit{lista} de arquivos e pastas que estão dentro do diretório no qual está trabalhando. Por exemplo, em um sistema
	de uso pessoal, é esperado que \texttt{/home/user} tenha pastas como \texttt{Videos, Downloads, Imagens, Musica}, entre
	outras. 
	
	\subsubsection{Mudança de diretório. O cd} 

	Você também vai querer entrar e sair de demais pastas durante seu trabalho no computador. O comando de \textit{change
	directory}, \texttt{cd}, permite a navegação no sistema. Para acessar a pasta um nível acima da qual você está, use 
	\texttt{cd ..} 


	Caso o diretório esteja na mesma pasta em que você se encontra, simplesmente adicione o nome desta depois do comando. 
	Por exemplo, \texttt{cd Videos} te leva aos seus vídeos. Você pode, também, ir para um \textit{local qualquer} no sistema
	de arquivos digitando seu \textit{path}. Para acessar uma pasta com programas instalados, use seu caminho como 
	\textbf{argumento} do comando. Por exemplo: 
	
	\vspace{1ex}
	\texttt{cd /usr/bin} 
	\vspace{1ex}

	\subsubsection{Entrada e saída (I/O)}

	Aqui, trataremos de comandos que fazem \textit{writes}, ou "escritas", e, portanto, entram e saiem com \textit{bytes} em disco. 

	\paragraph{Criação de arquivo:} 
	\paragraph{}
	Para gerar um arquivo de tipo qualquer, use o \texttt{touch}: 
	
	\begin{enumerate} 
		\item{Arquivo de texto: \texttt{touch Documentos/meuTexto.txt}} 
		\item{Arquivo de vídeo: \texttt{touch ../meuVideo.mp4}}
		\item{Arquivo de imagem: \texttt{touch /porDoSol.png}}
		\item{Arquivo qualquer: \texttt{touch arquivoGenerico}}
	\end{enumerate}

	\paragraph{Copiando arquivos:} 
	\paragraph{} 
	O comando \texttt{cp} permite que você copie arquivos de um lugar para outro. Vejamos seu uso: 
	\begin{enumerate} 
		\item{Copiando um arquivo: \texttt{cp Documentos/meuTexto.txt .}}
		\item{Copiando uma pasta: \texttt{cp -R Videos Documentos}}
	\end{enumerate} 


	Tá, temos coisas novas aqui. Primeiramente, repare que o comando toma dois parâmetros. O primeiro é 
	o caminho do objeto \textit{a ser copiado}, enquanto que o segundo é o caminho \textit{para onde} ele será copiado. 
	
	Em segundo lugar, veja no caso 1 que copiei o arquivo de texto \texttt{meuTexto.txt} da pasta \texttt{Documentos} 
	para o diretório no qual \textit{atualmente estou}. Se lembra que \texttt{..} representa a pasta um nível acima
	na hierarquia? Então, um ponto sozinho simboliza a pasta na qual você está trabalhando. 
	
	Por fim, para copiar uma pasta passamos uma \textit{flag} para \texttt{cp} junto de seus argumentos. 
	A \textit{flag} \texttt{-R} funciona como um modificador do comando e, nesse caso, manda o \texttt{cp}
	copiar \textbf{recursivamente} o arquivo especificado, ou seja, o comando "entra" na pasta e copia o que
	tem dentro dela, \textbf{incluindo} a própria pasta. 

	
	\paragraph{Movendo arquivos}
	\paragraph{}

	Mover arquivos funciona de forma análoga ao \texttt{cp}, com uma diferença significativa sendo que não é necessário 
	especificar a \textit{flag} \texttt{-R} para mover pastas - basta usar o comando como se fossem arquivos ordinários. 

	\begin{enumerate} 
		\item{\texttt{mv Documentos DocumentosSecretos}} 
		\item{\texttt{mv Videos/meuVideo.mp4 Downloads}} 
		\item{\texttt{mv meuTexto.txt Downloads/curriculo.txt}} 
	\end{enumerate} 

	Aqui, temos 3 usos distintos do \texttt{mv}. Vejamos um por um. No primeiro, estamos \textit{renomeando} a pasta de 
	nome \texttt{Documentos} para \texttt{DocumentosSecretos}, a qual está no diretório no qual se está trabalhando. 


	Em segundo lugar, de fato movemos o arquivo \texttt{meuVideo.mp4} na pasta Videos para a pasta Downloads. Repare, no 
	entanto, que caso a pasta Downloads \textbf{não} existisse, o arquivo de vídeo seria "convertido" em um arquivo 
	genérico de nome \texttt{Downloads}, o que acarretaria uma \textit{perda de informação} grave. Por mais óbvio que isso
	seja, certifique-se de que o destino para o qual quer mover seus dados realmente exista. 


	Finalmente, juntamos os dois casos acima em um terceiro. Aqui, movemos o arquivo \texttt{meuTexto.txt}, presente na pasta
	atual, para a pasta Downloads \textbf{e} renomeamos o arquivo para \texttt{curriculo.txt}. Fizemos duas tarefas em um 
	só comando. Esse é apenas um exemplo trivial de como é possível aumentar sua produtividade usando a CLI. 
	
	\paragraph{Apagando arquivos} 
	\paragraph{} 

	Essa seção requer atenção especial devido a possíveis catástrofes que podem acontecer no sistema. A não ser que você 
	configure-o ou utilize pacotes/programas adicionais para criá-lo, o conceito de lixeira, presente em sistemas
	como Windows e MacOS, \textbf{não existe} na linha de comando de SOs \textit{Unix-like} como Linux. 


	Em essência, a lixeira nada mais é do que uma pasta especial, na qual os dados ficam indefinidamente até que a pessoa
	utilizando o computador possa avaliar se os quer ou não. Nesse sentido, no mundo do CLI, para colocar algo na lixeira,
	faríamos: 
	
	\vspace{1ex} 
	\texttt{mv arquivoIndesejado /caminho/para/a/lixeira} 
	\vspace{1ex} 

	Mas isso não é nada prático. Poderíamos usar um apelido, ou \textit{alias}, para tornar o comando acima algo menor 
	como \texttt{lixo}, mas este recurso será tratado em breve. No meio tempo, pode-se simplesmente apagar,
	\textbf{de forma irreversível}, um dado arquivo. 

	Para isso, vamos \textit{remover} o arquivo usando \texttt{rm}. A sintaxe é bem simples: 
	\begin{enumerate} 
		\item{\texttt{rm textoIndesejado.txt}} 
		\item{\texttt{rm -r pastaIndesejada}} 
		\item{\texttt{rm -i videoPotencialmenteIndesejado}} 
	\end{enumerate}

	Novamente, temos 3 casos. Nos dois primeiros, apagamos um arquivo de texto e, no segundo, apagamos uma pasta usando 
	a \textit{flag} recursiva \texttt{-r}. A terceira opção é mais segura, uma vez que a \textit{flag} \texttt{-i} trata a ação de forma
	interativa. O que isso quer dizer é que quando você clicar Enter para apagar, o sistema irá retornar uma mensagem 
	pedindo que você confirme sua ação com um sim ou não. Geralmente, isso se dá assim:
	
	\vspace{1ex}
	\texttt{rm: remove regular file?} 
	\vspace{1ex} 
	
	Para o qual você digita \texttt{y} ou \texttt{n} para sim ou não, respectivamente. 

	\subsection{Visualizando arquivos. O cat} 

	Vamos tratar de uma ferramenta muito útil para visualizar arquivos de texto. Veja, o comando \texttt{cat} abre 
	\textit{qualquer} tipo de arquivo para visualização. No entanto, abrir arquivos que não de texto irá renderizar 
	uma visualização esquisita em algo parecido com hexadecimal.

	\begin{figure}[ht!]
  		\centering
		\includegraphics[scale=0.3]{figs/brokenCat.png} 
  		\caption*{Visualização quebrada de um PDF utilizando o cat}
	\end{figure}


	Por outro lado, executar o comando em um arquivo de texto normal, irá mostrar corretamente seu conteúdo. 
	Suponha que você tenha um arquivo chamado \texttt{listaDeCompras} estruturado da seguinte forma:

	\begin{enumerate}
		\item{Banana}
		\item{Laranja} 
		\item{Livro de Álgebra Linear} 
		\item{Leite desnatado} 
		\item{Cubo mágico} 
	\end{enumerate} 

	Rodar \texttt{cat listaDeCompras} irá lhe mostrar uma lista estruturada exatamente igual da forma como você a escreveu. 
	Note que desde que o arquivo seja de texto, sua visualização será idêntica. O que isso significa é que caso você receba um 
	arquivo de texto do Windows, isto é, terminado em \texttt{.txt} e e ele estiver em um formato universal no qual 
	seu computador trabalha como UTF-8 ou ASCII e não estiver corrompido, sua visualização será igual a de um arquivo 
	de texto do Linux. Para visualizá-lo: 

	\vspace{1ex}
	\texttt{cat textoDoWindows.txt} 
	\vspace{1ex} 

	\subsection{Editando textos} 

	O assunto edição de textos no terminal é extenso e vai além do que esse livro propõe. Ainda assim, vou lhe mostrar como abrir 
	um arquivo de texto e começar a editá-lo. Imagine que você queira escrever a lista do tópico anterior em um arquivo chamado 
	\texttt{compras.txt}. Para isso, você faria: 
	
	\vspace{1ex} 
	\texttt{nano compras.txt} 
	\vspace{1ex}

	Entenda que \texttt{nano} não é exatamente um "comando" como estamos tratando aqui. Ele é apenas um dos inúmeros 
	programas de edição de texto CLI que existem. Fiz referência a ele devido à sua fácil utilização, mas existem
	outras opções mais configuráveis como o \texttt{emacs}, o \texttt{vim} (meu preferido) e o \texttt{micro}. 

	\newpage

	\section{Python} 

	Nessa seção iremos iniciar a tratar do assunto \textbf{programação de computadores}. No contexto desse livreto, 
	irei defini-la como escrever \textit{scripts}, traduzindo literalmente como "roteiros", que instruem o computador a fazer
	determinada(s) ação(ões). Como estamos em um nível iniciante, a melhor linguagem de programação para essa tarefa 
	é o Python. 

	\subsection{Contexto técnico} 

	A linguagem Python é \textit{interpretada}, o que significa que o código escrito por você \textbf{não} é "empacotado" e
	convertido em binário (0s e 1s que o computador lê em nível fundamental) como ocorre em linguagens \textit{compiladas}. 
	Isso gera um certo \textit{overhead} ("atraso") de performance para o programa ao mesmo tempo que proporciona grande 
	flexibilidade à linguagem. Sua natureza flexível, com o uso de \textbf{módulos}, é um dos pontos que fizeram Python 
	tão popular na computação moderna. 

	\subsection{Instalando módulos. O pip}

	Para tirar proveito dessas "extensões" da linguagem, devemos incluí-las em seu interpretador. Para tanto, vamos usar
	o gerenciador de pacotes nativo do Python para baixar os módulos diretamente do \href{https://pypi.org/}{PyPI}.
	Esse programa se chama \texttt{pip} e pode ser invocado diretamente da linha de comando: 

	\vspace{1ex}
	\texttt{pip install módulo1 módulo2 módulo3 ...} (1)
	\vspace{1ex} 

	Caso esteja usando um sistema Linux atual, é esperado que o \texttt{pip} já esteja instalado no sistema (assim como o Python). 
	Caso contrário, instale-o pelo próprio terminal. Em sistemas Ubuntu/Debian, você faria: 

	\vspace{1ex} 
	\texttt{sudo apt install python python-pip} (2)
	\vspace{1ex} 

	e digitaria sua senha de usuário. Em seguida, tente reinstalar os módulos pelo \texttt{pip}. Note, contudo, que rodar o comando 
	(1) irá instala-los no interpretador \textbf{global} do Python. Isso não é exatamente um problema, mas na maior 
	parte dos casos, é tido como uma má prática porque você pode querer trabalhar com o mesmo módulo de diferentes versões,
	podem acontecer problemas com determinadas versões/dependências e a técnica que vou mostrar em seguida deixa seu trabalho
	mais organizado. 

	\begin{figure}[ht!]
  		\centering
		\includegraphics[scale=0.2]{figs/modules.png} 
  		\caption*{Alguns dos módulos mais populares de Python}
	\end{figure}

	\newpage

	\subsection{Ambiente virtual. O venv} 

	Para solucionar esse "problema", as pessoas desenvolvedoras por trás do Python vieram com um conceito chamado ambiente
	virtual, o qual pode ser criado utilizando um módulo nativo da linguagem, espertamente chamado de \texttt{venv} para 
	\textit{Virtual Environment}.

	Suponha que você desenvolva um aplicativo de cálculo numérico e quer torná-lo disponível em seu site para uso público.
	Você poderia logar em seu servidor com SSH e criar um ambiente na sua \textit{home} que irá conter o aplicativo. 
	Vamos criá-lo: 
	
	\vspace{1ex}
	\texttt{python -m venv calculoNumerico} 
	\vspace{1ex} 

	Veja aqui que passei a \textit{flag} \texttt{-m} para o interpretador, uma vez que não estou apenas invocando o interpretador Python,
	mas um módulo específico para criação de \textit{venvs}. Esse módulo, por sua vez, recebe um argumento que é o nome do 
	ambiente virtual.

	Agora existe uma pasta chamada \texttt{calculoNumerico} em seu diretório atual, a qual pode ser acessada usando \texttt{cd}. 
	Ao entrar na pasta do \textit{venv}, você ainda \textbf{não} estará propriamente no ambiente. Veja, usando \texttt{ls},
	que existem algumas sub-pastas como \texttt{bin, include, lib, lib64} e um arquivo \texttt{pyenv.cfg}. O que aconteceu aqui
	é que agora existe um "mini Python" nessa pasta, e você pode adicionar, mover e apagar pastas e arquivos à vontade dentro
	do diretório do \textit{venv} sem afetar a instalação global. 

	\subsubsection{Ativando o ambiente} 

	Para propriamente "entrar" no \textit{venv}, você deve carregar uma configuração específica para a sua \textit{shell}. 
	Essa configuração está na forma de um script dentro da pasta \texttt{bin} do ambiente virtual e pode ser carregada usando o 
	comando \texttt{source}. Então, dentro da pasta de seu \textit{venv}, faça:

	\vspace{1ex}
	\texttt{source bin/activate}
	\vspace{1ex} 

	o que irá ativar o ambiente virtual. A partir de agora, podemos instalar os pacotes usando \texttt{pip} e eles estarão
	isolados da instalação global do Python. 

	\vspace{1ex} 
	\texttt{(calculoNumerico) pip install numpy Flask pandas} 
	\vspace{1ex} 

	Isso irá instalar módulos para computação numérica (\texttt{numpy}), \textit{backend} (\texttt{Flask}) e
	análise de dados (\texttt{pandas}) no ambiente virtual de nome \texttt{calculoNumerico}. Após editar e executar todos
	os arquivos necessários, saia do ambiente virtual simplesmente digitando \texttt{deactivate} no terminal. 

	\section{Git} 

	Na seção final do livro, será discutido o \textbf{controle de versionamento} de código. Para esse propósito, iremos utilizar 
	o software Git e uma plataforma de compartilhamento de código que o utilize - existem várias como GitLab, Gitea, Codeberg etc, mas
	aqui iremos usar a mais popular, o \href{https://github.com/}{GitHub}. Assim, comece criando uma conta gratuita em algum desses serviços.

	Feito isso, iremos instalar o Git em nosso sistema. Caso esteja usando Windows ou MacOS, o programa pode ser baixado 
	pelo seu \href{https://git-scm.com/}{site oficial}. Em sistemas \textit{Unix-like}, como o Linux, é possível obte-lo por um 
	gerenciador de pacotes. No Ubuntu Linux: 

	\vspace{1ex}
	\texttt{sudo apt install git}
	\vspace{1ex}

	Agora, podemos começar a fazer upload de nosso código e gerenciar suas versões a partir do nosso próprio computador! Mas antes,
	algumas definições importantes. 

	\subsection{Conceitos importantes}

	O Git é um software muito poderoso e para entendê-lo bem e utlizá-lo eficientemente, temos que aprender alguns conceitos 
	próprios dele e outros típicos de desenvolvimento de software no geral. 

	\subsubsection{O começo de tudo. O repositório}

	Quando uma pessoa cria uma conta no GitHub, seu perfil apresenta zero repositórios (ou \textit{repos}) porque ela não fez upload de nenhum 
	código. Pense nos repositórios como abas na sua conta que contém o \textit{código-fonte} do seu projeto. Por exemplo, 
	você pode ter um repo para uma calculadora em Python, um para um sistema operacional em C e Rust e outro para um site em 
	HTML, CSS e JavaScript. 

	Os repos podem ser \textbf{públicos}, ou seja, qualquer pessoa (até mesmo sem conta no site) pode visualizar o seu código ou 
	\textbf{privados}, nos quais apenas aquelas com conta e que você determinar poderão acessá-lo. 

	Vamos começar, então, a criar seu primeiro repositório no GitHub: 
	\begin{enumerate} 
		\item{Vá ao site do GitHub: \texttt{https://github.com}}
		\item{Procure um símbolo de $ + $ e clique neste}
		\item{Clique em "Criar novo repositório"}
	\end{enumerate}

	Aqui, você deve fornecer um nome ao repo que criar. Ele vai estar do lado do seu nome de usuário e poderá ser acessado 
	(caso seja público) diretamente da Internet pelo link genérico: 
	
	\vspace{1ex}
	\texttt{https://github.com/seuNomeDeUsuario/nomeDoRepo}
	\vspace{1ex}

	Logo abaixo do nome você fornece uma descrição opcional e seleciona se o repo deve ser público ou não. 
	Em seguida, certifique-se de que a caixa escrita \textit{"Adicionar um arquivo README"} esteja selecionada. 
	
	
	O \texttt{README.md} é como um guia do seu repositório e é uma boa prática que ele seja o primeiro arquivo no seu repo. 
	Independentemente de seu projeto ser público ou privado, esse arquivo deve ser bem escrito, explicitando as principais 
	\textit{guidelines} do seu repositório, as quais incluem, mas não se limitam a: 

	\begin{enumerate}
		\item{O que é o projeto}
		\item{Por que você criou esse projeto}
		\item{Quais linguagens e/ou \textit{frameworks} foram utilizados}
		\item{Contenha \textbf{documentação} ou, ao menos, direcione as pessoas a um arquivo/link que a contenha}
	\end{enumerate}

	Em seguida, na caixa escrita \textit{"Adicionar .gitignore"} deixa-a vazia. O \texttt{.gitignore} é um arquivo muito útil 
	que será abordado em breve. Por enquanto, seu repo não necessita deste. 
	
	Finalmente, você deve escolher uma licença. Caso seu software seja de código fechado, essa escolha não é muito sensível.
	Contudo, ao criar um repo público e, indiretamente, contribuir para a comunidade \textit{open source} é essencial que escolha 
	uma.

	A licença estabelece legalmente o que as pessoas podem fazer com seu programa e com seu código-fonte como copiá-lo, incorporá-lo,
	distribuí-lo de forma gratuita ou cobrando, entre muitas outras situações. O assunto é extenso e importante, então caso queira 
	aprender mais, consulte o \href{https://choosealicense.com/}{site referenciado pelo GitHub} para melhor escolher uma.

	No final da página, existe um botão verde escrito \textit{"Criar repositório"}. Clique nele. Parabéns, você criou seu primeiro 
	repo no GitHub!

	\subsubsection{O multiverso. Os branches}
	label{sec:branches}

	Com seu repositório criado, você pode ver que em sua página principal ao lado do símbolo \faIcon{code-branch}, está
	escrito \texttt{main} e, ao lado desse texto, \textit{1 branch}. Quando o GitHub cria um repo para você, ele lhe designa 
	apenas um \textit{branch}, o principal (ou \textit{main}, antigamente chamado de \textit{master}). 
	
	A palavra \textit{branch} traduz literalmente para "galho" e isso já te dá uma ideia de analogia para o desenvolvimento de 
	software. Pense no ciclo de desenvolvimento de um app como uma árvore: o caule seria o "galho principal" (o \textit{main})
	e as demais ramificações seriam branches com novas implementações.

	Por exemplo, imaginando o projeto de uma calculadora em Python, o caule do seu projeto contém implementações que você sabe 
	que não irão produzir erros para a pessoa usuária final como adição, subtração e multiplicação. Diz-se que \texttt{main} 
	está sem erros (\textit{bug-free}).
	
	Suponha, porém, que você deseja colocar divisão em seu projeto, afinal, é uma operação bem típica. No entanto, sabe-se que dividir
	qualquer número real por zero gera uma indeterminação. Isso pode criar uma \textbf{exceção} em seu programa e, se não for lidada, 
	acarreta um erro ou \textit{bug}. Como você não quer erros no \textbf{ambiente de produção} (aquele das pessoas que utilizam o software final),
	uma boa estratégia é criar um novo branch com a implementação de divisão. 

	Isso lhe dá tempo para pensar em formas de lidar com a exceção da divisão por 0 ao mesmo tempo que mantém a \textit{codebase}
	do seu projeto final intacta. Em outras palavras, você implementa algo novo no software, mas não quebra ele (de imediato).

	\begin{figure}[ht!]
		\centering
	  	\includegraphics[scale=0.3]{figs/software_tree.png} 
		\caption*{Projeto de calculadora com visualização em árvore Git}
  \end{figure}

  \subsubsection{Apêndice: paridade do desenvolvimento}

  A natureza do Git é permitir um fluxo de trabalho simples para escrever e, posteriormente, testar e mandar seu projeto para
  produção. Seja trabalhando como indivíduo ou em equipe, não se espera que você faça tudo em sua máquina - você vai querer
  mandar suas atualizações para um ambiente seguro, que possa ser acessado de qualquer lugar e, caso tenha um time, seja 
  compartilhado. Por isso, vou introduzir aqui dois conceitos simples para que possamos entender melhor as operações que 
  faremos em branches. 

  \paragraph{Local}
  \paragraph{}

  É o computador no qual você trabalha e instalou o Git no começo dessa seção. Esse pode ser seu aparelho pessoal ou 
  de trabalho, mas o mais importante é que você fará alterações aqui que serão enviadas para um servidor com seu código.

  \paragraph{Remoto}
  \paragraph{}

  Também chamado de \textit{upstream}, esse servidor pode estar na sua rede local (LAN) - o que é mais complicado de fazer e não será abordado aqui - ou na
  Internet (WAN). Um exemplo desse último caso é o GitHub, o qual usamos até aqui e para projetos simples é gratuito, sendo 
  mantido pela Microsoft. 

  \subsection{Operações com Git}

  Com esses conceitos consolidados, podemos começar a fazer operações para manter e controlar as versões do nosso código.
  Vamos começar, partindo do exemplo da \href{sec:branches}{seção 3.1.2}, trazendo o repositório criado do remoto para local para que você possa
  visualizar e editar seus arquivos. 

  \subsubsection{Remoto-Local. O clone}
  label{sec:clone}

  O comando \texttt{git clone} literalmente gera um clone de um repositório do \textit{upstream} para o local. Para começar, faça:
  
  \vspace{1ex}
  \texttt{git clone https://github.com/seuNomeDeUsuario/nomeDoRepo}
  \vspace{1ex}
  
  Note que esse comando irá copiar os arquivos do remoto em uma pasta chamada \texttt{nomeDoRepo} que, por sua vez, está na pasta
  em que você está trabalhando. Caso o diretório não existe, ele será criado. Para clonar um repositório para um local arbitrário: 

  \vspace{1ex}
  \texttt{git clone https://github.com/seuNomeDeUsuario/nomeDoRepo /path/para/o/local/desejado}
  \vspace{1ex}

  Nesse momento, os arquivos do remoto estão em seu PC. Para visualizá-los, faça \texttt{cd} na pasta. Repare que o seu terminal 
  antes estava mais ou menos assim:

  \vspace{1ex}
  \texttt{user@linux: ~}
  \vspace{1ex}

  E agora: 

  \vspace{1ex}
  \texttt{user@linux (main): ~}
  \vspace{1ex}

  Repare no parênteses. Ele indica o \textbf{branch} no qual você está trabalhando. Como seu repositório tem apenas o principal e o 
  comando \texttt{git clone} segue o padrão de \texttt{main}, esse branch foi clonado. Caso quisesse clonar outro branch, bastava
  passar a flag \texttt{-b} para o comando: 

  \vspace{1ex}
  \texttt{git clone https://github.com/seuNomeDeUsuario/nomeDoRepo pastaQualquer -b umBranchQualquer}
  \vspace{1ex}

  Mas como seu repositório possui apenas \textit{main}, o comando irá falhar. Em breve, veremos como criar branches a partir da CLI.

  \subsubsection{Tudo certo? O status}

  Até agora, seu projeto possui apenas o \texttt{README.md}, então vá em frente e o edite. Adicione seu nome, escreva uma piada ou 
  qualquer coisa. Depois de salvar o arquivo e voltar para o terminal, digite: 

  \vspace{1ex}
  \texttt{git status}
  \vspace{1ex}

  o que irá retornar algo como: 

  \vspace{1ex}
  \texttt{\\
  \noindent On branch main\\
  \noindent ...\\
  \noindent ...\\
  \noindent ...\\
  \noindent ...\\
  \noindent Changes not staged for commit:\\
  \noindent ......\\
  \noindent ......\\
  \noindent \textcolor{red}{modified:   README.md}}
  \vspace{1ex}


  E, de fato, o arquivo README foi modificado. Esse comando serve mais para que possa entender o que foi mudado, se realmente foi 
  mudado e se os arquivos que você quer intactos realmente estão. Depois dessa confirmação, nos preparamos para mandar nossas
  mudanças para \textit{upstream}. 
  
  \subsubsection{Fazendo as malas. O add}
  \label{sec:add}

  Para preparar o envio de arquivos novos ou modificados para remoto, fazemos: 
  
  \vspace{1ex}
  \texttt{git add arquivo1 pasta1 arquivo2 pasta2}
  \vspace{1ex}
  
  Apesar desse método ser válido, o que geralmente se faz é adicionar a própria pasta \textbf{raiz} do repositório (aquela criado pelo \texttt{git clone})
  com todos os arquivos e pastas recursivamente. Para tanto, escrevemos: 

  \vspace{1ex}
  \texttt{git add .}
  \vspace{1ex}

  Para projetos maiores isso pode ser problemático, pois estes geram pastas e arquivos temporários de cache, auxiliares etc. Numa próxima
  seção, veremos como ignorar esses arquivos com o arquivo \texttt{.gitignore}. Agora, porém, isso não é um problema. 
  Vamos seguir. 

  \subsubsection{Oficializando a saída. O commit}

  O conceito de \textbf{commit} é extremamente importante para controle de versionamento (VCS) e, em particular, para o Git. 
  A grosso modo, quanto mais commits um repositório tem, mais ativo ele é, ou seja, muitas mudanças são feitas para a \textit{codebase}
  e/ou para a documentação do projeto.

  O que você fez anteriormente foi clonar o repositório de remoto para local, editou um arquivo, 
  o colocou na "fila para saída/mudança" e, agora, você oficializa esse "feito" no repositório fazendo um commit ou,
  de forma mais legal, \textit{commitando}. Faça: 

  \vspace{1ex}
  \texttt{git commit -m \textquotesingle\!\textquotesingle editei o README. Escrevi meu nome\textquotesingle\!\textquotesingle}
  \vspace{1ex}

  Note a flag de mensagem \texttt{-m} que passei para o comando. À medida que as pessoas se tornam desenvolvedores mais experientes, 
  é comum que abandonem o hábito de commitar com mensagens. Tente evitar isso. É uma excelente prática demonstrar o que você está 
  mudando em um repositório. Isso ajuda as pessoas desenvolvedoras que trabalham com você, as pessoas que visualizam o código por foram
  de sua organização/empresa, as que vierem depois de você e, não ironicamente, você no futuro. 

  \subsubsection{Saindo. O push}

  Caso esteja se perguntando porque o \texttt{git commit} não é a etapa final para mudar algo no remoto, a resposta é que 
  \textit{"é por design"}. Por ora, vamos assumir que os commits são armazenados num registro, ou \textit{log}, do seu repositório. 
  Quando você editou \texttt{README.md}, algo foi mudado e o \texttt{git status} acusou isso. Contudo, não era "oficial" para o 
  sistema do Git. 
  
  Uma filosofia comum em desenvolvimento de software é a transparência e o registro histórico das mudanças. Os commits entram
  para fazer jus a isso. No momento em que digitou Enter no comando \texttt{git commit}, o seu repositório de fato foi alterado. 
  Agora, porém, seu repositório local está à frente do repositório remoto, uma vez que o primeiro possui um commit a mais. 

  Como consertar isso? Bem, vamos atualizar o remoto com as alterações do local. Para tanto, "empurramos" as mudanças locais 
  para o \textit{upstream}, isto é, fazemos um \textbf{push}.

  \vspace{1ex}
  \texttt{git push -u origin main}
  \vspace{1ex}

  Nota-se que o comando \texttt{git push} recebeu uma flag com um modificador e um argumento. Vejamos um por um: 

  \begin{enumerate}
	\item{\texttt{-u}: essa flag significa \textit{set upstream},ou seja, você está alterando o servidor remoto com suas mudanças}
	\item{\texttt{origin}: esse modificador indica que o \textit{upstream} é o próprio repositório trazido pelo \texttt{git clone}}
	\item{\texttt{main}: esse argumento especifica o branch para o qual as mudanças estão sendo feitas}
  \end{enumerate}

  Parabéns! Você baixou um repositório de um servidor remoto, fez as mudanças necessárias no seu computador, registrou-as com uma
  mensagem clara e sincronizou o remoto com as mudanças locais!  


  O passo a passo anterior deve cobrir as operações essenciais para você escrever código e mandar para o servidor do seu grupo 
  de pesquisa, empresa etc. O git, assim como a CLI no Linux, possui vários comandos e funcionalidades avançadas como o \texttt{merge}.
  Mas, esse livro é nada mais que uma introdução. Caso queira ler mais sobre o assunto, vou deixar algumas referências. 
  Agora, vou tratar de algumas peculiaridades do Git que foram úteis na minha vida como desenvolvedor. Elas vão desde mais simples a 
  mais elaboradas. 

  \subsubsection{Ignorando arquivos. O .gitignore}

  Esse arquivo já foi muito falado nesse livreto e chegou a hora de analisá-lo a fundo. Ele, assim como a pasta \texttt{.git} 
  é padrão do Git e são colocados na pasta do seu repo quando você o cria ou o clona. Tome o exemplo da 
  seção \href{sec:clone}{seção 3.2.1} e entre em seu diretório. Caso rode \texttt{ls}, deverá ver seu único arquivo, 
  \texttt{README.md}, mas existem arquivos "invisíveis". 
  
  Passe a flag \texttt{-A} para o \texttt{ls}, a qual lista \textbf{todos} os arquivos e diretórios presentes numa pasta. 
  Agora a pasta \texttt{.git} está visível. Os motivos de existirem arquivos invisíveis em seu sistema são várias e algumas delas são:
  
  \begin{itemize}
	\item{São gerados em massa}
	\item{São arquivos temporários}
	\item{Ocupam pouco espaço}
	\item{São removidos imediatamente após sua criação}
	\item{Não foram feitos para serem editados por pessoas não técnicas}
  \end{itemize}

  e, por isso, caso fossem visíveis, tornariam suas pastas muito confusas. Não se iluda, esse tipo de arquivo também existe no 
  Windows e no MacOS, só são mais difíceis de visualizar nesses SOs. 
  
  Dito isso, sinta-se à vontade para explorar o que há dentro da \texttt{.git}, mas nosso foco está no arquivo que iremos criar
  agora.

  \vspace{1ex}
  \texttt{touch .gitignore}
  \vspace{1ex}

  Criado o arquivo, podemos modificá-lo com um editor de terminal:  

  \vspace{1ex}
  \texttt{vim .gitignore}
  \vspace{1ex}

  A sintaxe do \texttt{.gitignore} é bem fácil. A cada linha você escreve o nome do arquivo ou pasta que deve 
  ser ignorado durante o \href{sec:add}{\texttt{git add}}. Um exemplo seria a criação de um aplicativo em 
  Python, o qual gera uma pasta de cache chamada \texttt{\_\_pycache\_\_}. Para não fazer upload de dados inúteis e que 
  irão onerar seu servidor, vale a pena retirá-los do ambiente de desenvolvimento. Nosso \texttt{.gitignore} seria algo assim: 

  \vspace{1ex}
  \texttt{\_\_pycache\_\_/}
  \vspace{1ex}

  e é isso. Para melhor ilustrar, vejamos um exemplo mais robusto: 
  
  \vspace{1ex}
  \texttt{\\ 
  \noindent webapp/\_\_pycache\_\_/  \\ 
  \noindent notas \\ 
  \noindent testes/teste0.log}
  \vspace{1ex}

  Aqui, ignoramos a pasta cache do Python dentro da pasta \texttt{webapp}, o arquivo de texto \texttt{notas} e o arquivo 
  de log \texttt{teste0.log} dentro da pasta \texttt{log}. Tudo que está escrito no \texttt{.gitignore} e está na raiz 
  do repositório não será adicionado para mudanças remotas com o \texttt{git add}.
  
  
\end{document}

% Sobre o autor
% OverLeaf
% StackOverflow
% ArchWiki e Wikipedia